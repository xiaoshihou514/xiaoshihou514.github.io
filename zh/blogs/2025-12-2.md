# 手把手教你ML类型推导，C++老登要长脑子了

这回我们直接搞定W算法。

## ML表达式的定义

```haskell
data MLTerm where
  V :: String -> MLTerm
  Const :: String -> MLTerm
  Ab :: String -> MLTerm -> MLTerm
  Ap :: MLTerm -> MLTerm -> MLTerm
  Let :: (String, MLTerm) -> MLTerm -> MLTerm
  Fix :: String -> MLTerm -> MLTerm
  deriving (Eq, Show)
```

比起LCNR，我们添加了常量和Let绑定。Let绑定和LCNR的赋值差不多，Fix和LCNR的LetRec差不多。常量就是编程语言的字面量，1、""、-32.1啥的。

## ML类型的定义

![](/binary/ml_tydef.png)

ML类型是很多编程语言的基础，所以这次我们要动真格了，基本类型和多态什么的都要好好定义。ML类型中多态类型被称为类型变量，一个类型要么是类型变量要么是基本类型c（Int、String等），然后可以用箭头组合。

第二行的意思是forall一定在最外层，即`forall a.a -> (forall b.b -> b)`不是一个ML类型。forall可以到处放的类型系统被称为F系统（System F），比ML更强大，但它已被证明没法做类型推导。

```haskell
data MLType
  = -- 类型变量
    Phi Char
  | -- Int，String...
    Basic String
  | Arrow MLType MLType
  | -- 这里为了简洁我们不强求量化一定在顶层
    Qtf Char MLType
  deriving (Show, Eq)
```

## ML系统中的类型替换
ML的系统替换包括所有柯里系统中的替换（柯里类型 -> ML类型变量），我们还需要定义类型变量到基本类型的替换。

![](/binary/ml_subdef.png)

## ML系统中的类型统一
同样的，ML系统中的类型统一需要考虑到基本类型：

![](/binary/ml_unify_def.png)

## 实现W算法

![](/binary/w_def.png)

首先注意W算法比起我们之前的算法多了一个v，这是个表／映射，用来判断常量是什么类型。于是定义Env类型：

```haskell
type PrincipalPair = (MLType -> MLType, MLType)

type Env = Map String MLType

algorithmW :: Env -> MLTerm -> Maybe MLType
algorithmW v term_ = snd . snd <$> algorithmW' emptyCtx term_
  where
    algorithmW' :: TypeCtx -> MLTerm -> Maybe (TypeCtx, PrincipalPair)
```

和之前一样我们还是要把TypeCtx传来传去，Env是个静态环境，所以我们直接捕捉该变量即可。

依旧是分情况讨论，首先考虑常量（1、"foo"、\[1, 2, 3]）：我们直接从环境获取类型，比如我们显然知道1是Int、双引号里面的内容是字符串等。注意这个类型可能是多态的，比如一个空数组[]的类型是`forall a.Array a`。

```haskell
algorithmW' ctx (Const s) = do
  a <- v !? s
  let (ctx', b) = freshInstance (ctx, a)
  return (ctx', (id, b))
```

这里我们需要该类型不和已有的类型变量冲突，因此有一个freshInstance替换：

```haskell
freshInstance :: (TypeCtx, MLType) -> (TypeCtx, MLType)
freshInstance = snd . freshInstance' Map.empty
  where
    freshInstance' ::
      Map Char MLType ->
      (TypeCtx, MLType) ->
      (Map Char MLType, (TypeCtx, MLType))
    -- 只替换非自由的类型变量
    freshInstance' env (ctx, Qtf c ty) =
      -- 添加所有被量化（quantified）的类型
      let (freshTy, ctx') = next ctx
          env' = Map.insert c freshTy env
       in freshInstance' env' (ctx', ty)
    -- 这里自由的类型变量我们直接不动
    freshInstance' env (ctx, Phi c) =
      case Map.lookup c env of
        Just ty -> (env, (ctx, ty))
        Nothing -> (env, (ctx, Phi c))
    freshInstance' env (ctx, Arrow left right) =
      let (env', (ctx', left')) = freshInstance' env (ctx, left)
          (env'', (ctx'', right')) = freshInstance' env' (ctx', right)
       in (env'', (ctx'', Arrow left' right'))
    freshInstance' env x = (env, x)
```

看到这里你可能会很奇怪：类型变量还能不被量化吗？

可以的兄弟，可以的。可以提前看一下抽象的推导，往环境里放的就是一个未被量化的phi。其实仔细想一下这是很合理的，我们提到ML类型只允许forall出现在顶层，那么推导的过程中我们需要带着没被量化的类型到处跑，最后一块量化。

那么到底什么时候量化呢？大约是已经推导到顶层，不需要再考虑替换的时候，所以观察到唯一添加量化的地方是Let（$\overline{S_1 \Gamma} A$那边）。可以认为Let这个域限定了它的抽象／具体程度。

我们继续看下一个情况，如果输入是一个变量，那么直接从上下文中读出类型，并同样做替换。

```haskell
algorithmW' ctx (V c) = do
  a <- env ctx !? c
  let (ctx', b) = freshInstance (ctx, a)
  return (ctx', (id, b))
```

在LC*中，我们都是返回一个新类型A，但在ML里，常量都有自己的类型，因此不会有自由变量，即从上下文一定能读到之前设的类型。

可以看到我们在抽象的情况确实把变量映射到了一个类型变量。
```haskell
algorithmW' ctx (Ab x e) = do
  let (phi, ctx') = next ctx
  (ctx'', (s, a)) <- algorithmW' (add x phi ctx') e
  return (ctx'', (s, s (phi --> a)))
```

Let是ML的新语法，大致效果和LCNR中的赋值差不多。我们首先推导绑定值的类型，然后将其量化（这时候要被放到in后面的式子里去开始推导了），推导后面式子的类型。具体怎么量化我们一会再说，先放个壳子：

```haskell
algorithmW' ctx (Let (x, e1) e2) = do
  (TypeCtx _ l, (s1, a)) <- algorithmW' ctx e1
  -- 这里代码有些复杂，大致来说，我们量化用的上下文是老的上下文
  -- 但我们的上下文还记录了目前用到的变量名，那个我们需要最新的
  -- 可以看到这里做替换只取了上下文
  let (TypeCtx mapping _) = apply s1 ctx
  -- 和最新的变量名组合起来
  let ctx'' = TypeCtx mapping l
  -- 量化x的类型
  let sigma = generalize ctx'' a
  -- 使用x推导e2的类型
  (ctx''', (s2, b)) <- algorithmW' (add x sigma ctx'') e2
  return (ctx''', (s2 . s1, b))

generalize :: TypeCtx -> MLType -> MLType
```

