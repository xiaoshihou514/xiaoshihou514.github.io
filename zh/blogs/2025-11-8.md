# æ‰‹æŠŠæ‰‹æ•™ä½ Lambdaå¼ç±»å‹æ¨å¯¼ï¼ŒC++è€ç™»éƒ½èƒ½çœ‹æ‡‚ï¼ˆ2ï¼‰

> [!CAUTION]
> C++è€ç™»å…¶å®çœ‹ä¸æ‡‚

> [!NOTE]
> **é¢„å¤‡çŸ¥è¯†**ï¼šä½ éœ€è¦ç†Ÿæ‚‰ Haskell çš„åŸºæœ¬è¯­æ³•ï¼Œäº†è§£é€’å½’å’Œé«˜é˜¶å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œä½ åº”è¯¥èƒ½è‡ªå·±å®ç° zipWithã€map è¿™æ ·çš„å‡½æ•°ã€‚

å¯¹åº”ä»£ç ï¼šhttps://github.com/xiaoshihou514/xingli

## å¼•è¨€

[ä¸Šå›](./2025-11-3)æˆ‘ä»¬å®ç°äº†ç±»å‹æ¨å¯¼çš„å‰ä¸¤ç§æƒ…å†µï¼ˆå˜é‡å’ŒæŠ½è±¡ï¼‰ï¼Œä½†å¡åœ¨äº†æœ€å¤æ‚çš„**åº”ç”¨**æƒ…å†µä¸Šã€‚æˆ‘ä»¬éœ€è¦æƒ³åŠæ³•ç»Ÿä¸€åº”ç”¨ä¸­å‡½æ•°å’Œå€¼çš„ç±»å‹ï¼š

```haskell
pp' ctx (Ap m n) = s2 . s1 $ (ctx1 `union` ctx3, a)
  where
    (ctx1, p1) = pp' ctx m
    (ctx2, p2) = pp' ctx1 n
    (a, ctx3) = next ctx2
    -- å…³é”®æ­¥éª¤ï¼
    s1 = unify p1 (p2 --> a)
    s2 = unifyctx (s1 ctx1) (s1 ctx3)
```

æˆ‘ä»¬ä»Šå¤©æ­£æ˜¯è¦â€œç»Ÿä¸€â€œ`p1`å’Œ`p2 --> a`ã€‚

## ç±»å‹ç»Ÿä¸€
å¦‚ä½•â€œç»Ÿä¸€â€ä¸¤ä¸ªç±»å‹å‘¢ï¼Ÿä¸»å¶ç®—æ³•è®¤ä¸ºï¼Œåº”å½“**æ›¿æ¢**æŸä¸ªåŸºæœ¬ç±»å‹ï¼Œè®©ä¸¤ä¸ªç±»å‹ç›¸ç­‰ï¼Œä¸¾ä¾‹æ¥è¯´ï¼šå¯¹äºå¼å­`f x`ï¼Œfä¸ºç±»å‹Aï¼Œxä¸ºç±»å‹Bï¼Œéœ€è¦ç»Ÿä¸€Aå’ŒB -> Cï¼Œè¿™é‡Œçš„æ›¿æ¢è§„åˆ™å°±éœ€è¦å°†Aæ›¿æ¢æˆB -> Cï¼Œä½¿å¾—A = B -> Cã€‚

::: tip
ğŸ’¡åŠ¨æ‰‹è¯•ä¸€è¯•ï¼šå¦‚ä½•ç»Ÿä¸€ä»¥ä¸‹ç±»å‹ï¼Ÿ
|   p1   | p2 --> a |
| :----: | :------: |
| B -> C |     A    |
| A -> B |  C -> D  |
|    A   |  A -> B  |
:::

ä¸»å¶ç®—æ³•å°†å…¶å®šä¹‰å¦‚ä¸‹ï¼š

![](/binary/pp_def_unify.png)

ä¸€å…±å››ç§æƒ…å†µï¼Œè¿™é‡Œ**phiä»£è¡¨åŸºæœ¬ç±»å‹ï¼ˆIntã€Stringï¼‰ï¼ŒAã€Bä»£è¡¨ä»»æ„æŸ¯é‡Œç±»å‹ï¼ˆå¯èƒ½æ˜¯å¤æ‚çš„ç®­å¤´ç±»å‹ï¼‰**ã€‚

- ä¸¤è¾¹éƒ½æ˜¯ç®€å•ç±»å‹ä¸”ç›¸ç­‰ï¼šä¸éœ€è¦æ›¿æ¢ï¼Œæœ¬æ¥å°±ä¸€æ ·
- å·¦è¾¹ç®€å•ç±»å‹ï¼Œå³è¾¹å¤æ‚ç±»å‹ï¼šè¿”å›ä¸€ä¸ªæ˜ å°„ï¼ŒæŠŠå·¦è¾¹æ˜ å°„åˆ°å³è¾¹ã€‚å¦‚æœå·¦è¾¹åœ¨å³è¾¹çš„ç±»å‹é‡Œå‡ºç°ï¼Œé‚£ä¹ˆä¸èƒ½ç»Ÿä¸€ï¼ˆå¦‚Aä¸è®ºå¦‚ä½•æ›¿æ¢A = A -> Béƒ½æ˜¾ç„¶ä¸æˆç«‹ï¼‰ã€‚
- å³è¾¹ç®€å•ç±»å‹ï¼Œå·¦è¾¹å¤æ‚ç±»å‹ï¼šåŒä¸Šã€‚
- å·¦å³éƒ½æ˜¯ç®­å¤´ç±»å‹ï¼šé¦–å…ˆé€’å½’å°è¯•ç»Ÿä¸€Aå’ŒCï¼Œæ ¹æ®æ˜ å°„ä¿®æ”¹Bã€Dï¼Œå†å°è¯•ç»Ÿä¸€Bã€Dï¼Œæœ€ç»ˆæ˜ å°„æ˜¯ä¸¤ä¸ªæ˜ å°„çš„ç»„åˆã€‚

äºæ˜¯å¯ä»¥å†™å¾—ï¼š
```haskell
unify :: CurryType -> CurryType -> (CurryType -> CurryType)
unify left right
  -- ä¸¤è¾¹ç›¸ç­‰
  | (Phi p1) <- left, (Phi p2) <- right, p1 == p2 = id
  -- å·¦ç®€å•å³å¤æ‚ï¼Œä¸”å·¦å¼ä¸èƒ½åœ¨å³å¼å‡ºç°
  | (Phi p) <- left, p `notOccur` right =
      -- å®šä¹‰æ›¿æ¢æ˜ å°„ï¼Œæ›¿æ¢æ‰€æœ‰pä¸ºright
      let subst ty = case ty of
            Phi _ -> if ty == left then right else ty
            Arrow a b -> Arrow (subst a) (subst b)
       in subst
  -- å·¦å¤æ‚å³ç®€å•
  | (Phi _) <- right = unify right left
  -- ä¸¤è¾¹å‡å¤æ‚
  | (Arrow a b) <- left,
    (Arrow c d) <- right =
      let s1 = unify a c            -- é¦–å…ˆç»Ÿä¸€Aã€C
          s2 = unify (s1 b) (s1 d)  -- æ ¹æ®æ›¿æ¢ä¿®æ”¹Bã€Dï¼Œç„¶åç»Ÿä¸€
       in s2 . s1                   -- ç»„åˆä¸¤ä¸ªæ˜ å°„
  | otherwise = error $ "Cannot unify " ++ prettyCT left ++ " and " ++ prettyCT right
```

å®šä¹‰`notOccur`å¦‚ä¸‹ï¼š
```haskell
notOccur :: Label -> CurryType -> Bool
notOccur p (Phi a) = p /= a
notOccur p (Arrow a b) = p `notOccur` a && p `notOccur` b
```

## ä¸Šä¸‹æ–‡ç»Ÿä¸€

ä¸¤è¾¹çš„ä¸Šä¸‹æ–‡ä¹Ÿå¯èƒ½å†²çªï¼Œè€ƒè™‘`xy(xz)`ï¼Œä¸¤è¾¹xçš„ç±»å‹æ˜¾ç„¶ä¸ä¸€æ ·ï¼ˆyå’Œzæ ¹æ®æˆ‘ä»¬ä¹‹å‰çš„é€»è¾‘ä¸å¯èƒ½ç›¸ç­‰ï¼Œé‚£ä¹ˆä¸¤ä¸ªxçš„è¾“å…¥ç±»å‹å°±è‚¯å®šä¸ä¸€æ ·ï¼‰ã€‚æˆ‘ä»¬éœ€è¦ç»Ÿä¸€ä¸¤ä¸ªä¸Šä¸‹æ–‡å¯¹å˜é‡çš„æè¿°ã€‚

![](/binary/pp_def_unifyctx.png)

ç»Ÿä¸€ä¸Šä¸‹æ–‡ç”¨åˆ°äº†ä¹‹å‰å®šä¹‰çš„unifyå‡½æ•°ï¼Œæ„æ€æ˜¯è¯´ï¼Œå¦‚æœæŸå˜é‡xåœ¨ä¸¤ä¸ªä¸Šä¸‹æ–‡ä¸­å‡æœ‰å®šä¹‰ï¼Œé‚£ä¹ˆæ‰€æœ‰è¿™æ ·çš„xéƒ½éœ€è¦è¢«ç»Ÿä¸€ï¼Œè€Œå…·æœ‰è¿™æ ·æ•ˆæœçš„æ˜ å°„æ˜¯æ‰€æœ‰å•ä¸ªå˜é‡ä¿®æ­£æ˜ å°„çš„ç»„åˆã€‚

è¿™é‡Œçš„Haskellä»£ç å¯èƒ½æ¯”è¾ƒå¤æ‚ï¼Œè¯•è¯•çœ‹èƒ½ä¸èƒ½çœ‹æ‡‚å§ï¼
```haskell
unifyctx :: TypeCtx -> TypeCtx -> (PrincipalPair -> PrincipalPair)
unifyctx ctx1 ctx2 = liftPP $ foldr (.) id subs
  where
    subs = [unify a b | (x, a) <- Map.toList env1, b <- maybeToList $ Map.lookup x env2]
    env1 = env ctx1
    env2 = env ctx2

liftPP :: (CurryType -> CurryType) -> (PrincipalPair -> PrincipalPair)
liftPP f (TypeCtx env l, a) = (TypeCtx (Map.map f env) l, f a)
```

é¦–å…ˆæˆ‘ä»¬è·å–æ‰€æœ‰è¢«äºŒæ¬¡å®šä¹‰çš„å˜é‡ï¼Œå¹¶æ‰¾å‡ºå®ƒä»¬çš„ä¿®æ­£æ˜ å°„ï¼š
```haskell
env1 = env ctx1
env2 = env ctx2
subs = [unify a b |
    (x, a) <- Map.toList env1,
    -- <-å¹¶ä¸èƒ½æå–Maybeä¸­çš„å€¼ï¼Œå› æ­¤æŠŠå®ƒè½¬æˆåˆ—è¡¨
    b <- maybeToList $ Map.lookup x env2
]
```

ä½¿ç”¨foldrç»„åˆæ‰€æœ‰æ˜ å°„ï¼š
```haskell
foldr (.) id subs
```

æˆ‘ä»¬ç°åœ¨å¾—åˆ°çš„æ˜ å°„åªèƒ½ä¿®æ­£ä¸€ä¸ªç±»å‹ï¼Œä¸ºäº†èƒ½å¤Ÿå°†å…¶åº”ç”¨äºæ•´ä¸ªä¸Šä¸‹æ–‡ï¼Œå®šä¹‰liftPPå°†å…¶ä½œç”¨äºæ‰€æœ‰ä¸Šä¸‹æ–‡ä¸­çš„ç±»å‹ã€‚

```haskell
liftPP :: (CurryType -> CurryType) -> (PrincipalPair -> PrincipalPair)
liftPP f (TypeCtx env l, a) = (TypeCtx (Map.map f env) l, f a)
```

## ç»“æŸäº†...å—ï¼Ÿ

![](/binary/pp_the_end.png)

å‰æ–‡æ²¡å†™å®Œçš„æœ€åä¸€ç§æƒ…å†µå°±å¯ä»¥è¡¥å…¨äº†ï¼š

```haskell
-- åªæ˜¯liftäº†ä¸€ä¸‹s1ï¼Œåˆ«çš„ä¸€ç‚¹æ²¡æ”¹
pp' ctx (Ap m n) = s2 . liftPP s1 $ (ctx1 `union` ctx3, a)
  where
    -- é¦–å…ˆé€’å½’æ¨å¯¼å‡½æ•°
    (ctx1, p1) = pp' ctx m
    -- é€’å½’æ¨å¯¼è¾“å…¥
    (ctx2, p2) = pp' ctx1 n
    -- ç»Ÿä¸€ä¸¤ä¸ªç±»å‹
    (a, ctx3) = next ctx2
    s1 = unify p1 (p2 --> a)
    -- ç»Ÿä¸€ä¸Šä¸‹æ–‡çš„ç±»å‹
    s2 = unifyctx (s1 ctx1) (s1 ctx3)
```

**ä¸¾ä¸ªå…·ä½“ä¾‹å­**ï¼šæ¨å¯¼ `(\x.x) y`
1. æ¨å¯¼ `(\x.x)`ï¼šå¾—åˆ° `{x: A}`, ç±»å‹ `A -> A`
2. æ¨å¯¼ `y`ï¼šå¾—åˆ° `{x: A, y: B}`, ç±»å‹ `B`  
3. æ–°ç±»å‹å˜é‡ï¼š`C`
4. ç»Ÿä¸€ `A->A` å’Œ `B->C`ï¼š
   - ç»Ÿä¸€ `A` å’Œ `B`ï¼šæŠŠAæ˜ å°„åˆ°B
   - ç»Ÿä¸€ `A` å’Œ `C`ï¼šä½†Aå·²ç»æ˜¯Bäº†ï¼Œæ‰€ä»¥ç»Ÿä¸€Bå’ŒCï¼ŒæŠŠBæ˜ å°„åˆ°C
   - æœ€ç»ˆï¼šAâ†¦C, Bâ†¦C
5. åº”ç”¨æ›¿æ¢åï¼šç±»å‹æ˜¯ `C`ï¼Œä¸Šä¸‹æ–‡æ˜¯ `{x: C, y: C}`

é‚£ä¹ˆåˆ°è¿™å…¶å®å°±å®ç°å®Œäº†ï¼Œä¸‹é¢æ˜¯Haskellå°è¯¾å ‚æ—¶é—´ã€‚

## ä¸€ç‚¹é‡æ„
æ³¨æ„åˆ°æˆ‘ä»¬åœ¨unifyé‡Œä¼šç›´æ¥æŠ¥é”™ï¼Œè¿™å…¶å®ä¸å¤ªå¥½ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ç±»å‹é‡Œå®£ç§°æˆ‘ä»¬å¯ä»¥æ¨å¯¼ä»»æ„Lambdaå¼çš„ç±»å‹ï¼Œä½†æˆ‘ä»¬æœ‰æ—¶å€™å´æ¨ä¸å‡ºæ¥ï¼ˆå¯ä»¥å°è¯•æ¨å¯¼ä¸€ä¸‹`\x.(x x) \x.(x x)`ï¼‰ã€‚

åœ¨Haskellé‡Œï¼Œæœ€ç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯è¿”å›ä¸€ä¸ªMaybeï¼Œæ˜ç¡®è¡¨ç¤ºå¯èƒ½æ¨ä¸å‡ºç±»å‹ï¼š

```haskell
unify :: CurryType -> CurryType -> Maybe (CurryType -> CurryType)
unify left right
  -- å‰å‡ ä¸ªæƒ…å†µåŠ ä¸€ä¸ªJustå³å¯
  | (Phi p1) <- left, (Phi p2) <- right, p1 == p2 = Just id
  | (Phi p) <- left, p `notOccur` right =
      let subst ty = case ty of
            Phi _ -> if ty == left then right else ty
            Arrow a b -> Arrow (subst a) (subst b)
       in Just subst
  | (Phi _) <- right = unify right left
  -- è¿™é‡Œç”¨äº†doè¯­æ³•é“¾å¼å¤„ç†Maybe
  | (Arrow a b) <- left,
    (Arrow c d) <- right = do
      s1 <- unify a c           -- å¦‚æœå¤±è´¥ï¼Œç›´æ¥è¿”å›Nothing
      s2 <- unify (s1 b) (s1 d) -- åŒä¸Š
      return $ s2 . s1          -- return = Just
  | otherwise = Nothing
```

```haskell
pp :: Term -> PrincipalPair -- [!code --]
pp :: Term -> Maybe PrincipalPair -- [!code ++]
pp = pp' emptyEnv
  where
    pp' :: TypeCtx -> Term -> PrincipalPair -- [!code --]
    pp' :: TypeCtx -> Term -> Maybe PrincipalPair -- [!code ++]
    pp' = ...
```

è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨äº†doè¯­æ³•ï¼Œæ•ˆæœä¸Šæ¥è¯´ï¼Œ`x <- ...`ä¼šâ€œè§£åŒ…â€Maybeï¼Œå¦‚æœæ˜¯ç©ºçš„ï¼Œç›´æ¥è¿”å›ç©ºï¼Œå¦åˆ™å°†å€¼å–å‡ºæ¥ã€‚ç”±äºnextä¸€å®šæˆåŠŸï¼ˆä¸è¿”å›Maybeï¼‰ï¼Œå› æ­¤ç”¨letè¯­æ³•è¡¨ç¤ºä¸éœ€è¦è§£åŒ…ã€‚æœ€åçš„returnç›¸å½“äºæ‰“åŒ…ï¼ˆJustä¸€ä¸‹ï¼ŒMaybeçš„Monadå®ç°ï¼‰ã€‚

è¿˜éœ€è¦ä¿®æ”¹ä¸Šå±‚ä»£ç ï¼š

ç”±äºå‰ä¸‰ç§æƒ…å†µä¸€å®šæˆåŠŸï¼Œæ‰€ä»¥åªéœ€åŠ ä¸€ä¸ªJustæ»¡è¶³ç±»å‹çº¦æŸå³å¯ã€‚
```haskell
pp' :: TypeCtx -> Term -> Maybe PrincipalPair
pp' ctx (V c) =
  let (a, ctx') = next ctx
   in (add c a ctx', a) -- [!code --]
   in Just (add c a ctx', a) -- [!code ++]
pp' ctx (Ab x m) = do
  (ctx', p) <- pp' ctx m
  case env ctx' !? x of
    Just ty -> Just (ctx', ty --> p)
    Nothing ->
      let (a, ctx'') = next ctx'
      in (add x a ctx'', a --> p) -- [!code --]
      in Just (add x a ctx'', a --> p) -- [!code ++]
```

æœ€åä¸€ç§æƒ…å†µï¼ŒåŒæ ·ä½¿ç”¨doè¯­æ³•å¤„ç†ï¼š
```haskell
pp' ctx (Ap m n) = s2 . liftPP s1 $ (ctx1 `union` ctx3, a) -- [!code --]
  where -- [!code --]
    (ctx1, p1) = pp' ctx m -- [!code --]
    (ctx2, p2) = pp' ctx1 n -- [!code --]
    (a, ctx3) = next ctx2 -- [!code --]
    s1 = unify p1 (p2 --> a) -- [!code --]
    s2 = unifyctx (s1 ctx1) (s1 ctx3) -- [!code --]
pp' ctx (Ap m n) = do -- [!code ++]
  (ctx1, p1) <- pp' ctx m -- [!code ++]
  (ctx2, p2) <- pp' ctx1 n -- [!code ++]
  let (a, ctx3) = next ctx2 -- [!code ++]
  s1 <- unify p1 (p2 --> a) -- [!code ++]
  s2 <- unifyctx (apply s1 ctx1) (apply s1 ctx3) -- [!code ++]
  return $ s2 . liftPP s1 $ (ctx1 `union` ctx3, a) -- [!code ++]
```

æœ€åæˆ‘ä»¬éœ€è¦ä¿®æ”¹ä¸€ä¸‹unifyctxï¼š

```haskell
subs :: [Maybe (CurryType -> CurryType)]
unifyctx ctx1 ctx2 = liftPP . foldr (.) id subs -- [!code --]
unifyctx ctx1 ctx2 = liftPP . foldr (.) id <$> sequence subs -- [!code ++]
```

è¿™é‡Œ`<$>`åªæ˜¯fmapçš„å¦ä¸€ç§å†™æ³•ï¼ˆå›å¿†ä¸€ä¸‹ï¼ŒMaybeå¯¹åº”çš„fmapæ˜¯ä»€ä¹ˆæ•ˆæœï¼Ÿï¼‰

`sequence`æ¯”è¾ƒå¤æ‚ï¼Œé¦–å…ˆçœ‹ä¸€ä¸‹å®ƒçš„ç±»å‹ï¼š

```haskell
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
-- ä¸Šè¿°è°ƒç”¨çš„å…·ä½“ç±»å‹ï¼št = [a], m = Maybe
sequence :: [Maybe (... -> ...)] -> Maybe [... -> ...]
```

å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯å¦‚æœåˆ—è¡¨é‡Œæœ‰ä¸€ä¸ªNothingï¼ˆå¤±è´¥äº†ï¼‰ï¼Œé‚£å°±æ•´ä½“è¿”å›Nothingï¼ˆæ•´ä½“å¤±è´¥ï¼‰ï¼Œåä¹‹åˆ™è¿”å›`Just [...]`ã€‚è¿™æ­£æ˜¯æˆ‘ä»¬æƒ³è¦çš„ã€‚

## åŠ¨åŠ¨æ‰‹ï¼ŒåŠ¨åŠ¨è„‘

**é—®é¢˜1**
æ‰‹åŠ¨æ¨å¯¼ `(\x.\y.x) (\z.z)` çš„ç±»å‹ï¼š
- æŒ‰æ­¥éª¤å†™å‡ºæ¯ä¸ªæ¨å¯¼é˜¶æ®µçš„ä¸Šä¸‹æ–‡å’Œç±»å‹
- æ¯æ¬¡ç±»å‹ç»Ÿä¸€çš„æ›¿æ¢æ˜ å°„æ˜¯ä»€ä¹ˆï¼Ÿ

**é—®é¢˜2**
ä¸ºä»€ä¹ˆ `\x.(x x)` æ— æ³•æ¨å¯¼å‡ºç±»å‹ï¼Ÿå°è¯•æ‰‹åŠ¨æ¨å¯¼å¹¶æ‰¾å‡ºé—®é¢˜æ‰€åœ¨ã€‚

**é—®é¢˜3**
æ€è€ƒé¢˜ï¼šæˆ‘ä»¬æ— æ³•æ¨å¯¼æ‰€æœ‰**ä¸åŠ¨ç‚¹ç»„åˆå­**ï¼ˆå› ä¸ºå®ƒä»¬éƒ½æœ‰è‡ªåº”ç”¨ï¼ŒAå’ŒA -> Aæ²¡æ³•ç»Ÿä¸€ï¼‰ï¼Œæˆ‘ä»¬ä¾èµ–ä¸åŠ¨ç‚¹ç»„åˆå­æ¥è¡¨è¾¾é€’å½’ï¼Œæ‰€ä»¥æˆ‘ä»¬ç°åœ¨è¿˜æ²¡æ³•æ¨å¯¼é€’å½’å‡½æ•°çš„ç±»å‹ã€‚å¯ä»¥æ€ä¹ˆè§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿ

---

æ­å–œï¼ä½ ç°åœ¨å·²ç»ç†è§£äº†ä¸€ä¸ªå®Œæ•´çš„ç±»å‹æ¨å¯¼ç®—æ³•ã€‚

> å®Œæ•´ä»£ç å‚è€ƒï¼š[GitHubä»“åº“](https://github.com/xiaoshihou514/xingli)

å½“ç„¶ï¼Œè¿™åªæ˜¯æœ€ç®€å•çš„ç±»å‹ç³»ç»Ÿ \:)

å¦‚æœä½ æƒ³çŸ¥é“å¦‚ä½•æ¨å¯¼æ›´å¤æ‚çš„æƒ…å†µï¼ˆå¦‚ä½•æ¨å¯¼whereï¼Ÿå¦‚ä½•æ¨å¯¼é€’å½’å‡½æ•°ï¼Ÿï¼‰ï¼Œå¯ä»¥çœ‹æˆ‘çš„ä¸‹ä¸€ç¯‡åšå®¢ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ä¼šé€æ­¥å¼•å…¥æ›´å¤šæ¦‚å¿µï¼Œè®©Lambdaå¼é€æ¸å¯ä»¥è¡¨è¾¾Haskellä¸­çš„ä»»æ„è¡¨è¾¾å¼ã€‚
