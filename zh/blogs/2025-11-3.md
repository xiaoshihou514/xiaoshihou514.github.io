# 手把手教你Lambda式类型推导，C++老登都能看懂（1）

> [!CAUTION]
> C++老登其实看不懂

> [!NOTE]
> **预备知识**：你需要熟悉 Haskell 的基本语法，了解递归和高阶函数。例如，你应该能自己实现 zipWith、map 这样的函数。

对应代码：https://github.com/xiaoshihou514/xingli

## 基础定义
首先，定义Lambda式和类型。

### Lambda式
我们先来看几个例子：
- x（一个变量）
- \x.x（恒等函数 id）
- \x.\y.x（总是返回第一个参数的函数，left）
- (\x.\y.x) (\x.x) = left id

Lambda 表达式的语法由以下三条规则递归定义：

Lambda式有以下递归定义（太长不看）：
- *变量*：`x`，`y`，`z`...
- *抽象*：`\x.M`，`M`为Lambda式（相当于Haskell中的匿名函数）
- *应用*：`M N`，`M`、`N`为Lambda式（相当于函数调用）

### 类型
例：`A`、`A -> B`、`(A -> B) -> C`、`(A -> B) -> A -> B`

这里我们使用最简单的柯里类型系统，即：或基本类型（Int、String等，这篇博客统一用A、B）、或箭头类型`类型 -> 类型`（与Haskell类型相同）

### 在Haskell中的表示
```haskell
data Term = V Char          -- 变量，如 'x'
          | Ab Char Term    -- 抽象，如 \x.M
          | Ap Term Term    -- 应用，如 M N
  deriving (Eq, Show)

data CurryType = Phi Char                   -- 基本类型，如 A、B
               | Arrow CurryType CurryType  -- 函数类型，如 A -> B
  deriving (Show, Eq)

-- 为了方便，我们为 Arrow 定义一个中缀运算符
(-->) :: CurryType -> CurryType -> CurryType
(-->) = Arrow
```
我们希望能够推出`\x.x`的类型是`A -> A`，`\f.\g.\x.f (g x)`的类型是`(B -> C) -> (A -> B) -> A -> C`等。

::: tip
💡动手试一试：你能尝试用Haskell写一个函数**验证**类型是否正确吗？这比推导类型简单得多！
:::

![](/binary/pp_def_verify.png)

## 如何实现：从类型签名开始
我们将实现一个称为*主偶算法*的类型推导算法。它的定义如下：

![](/binary/pp_def_main.png)

如果你已经看懂了，那恭喜你，你也没有看下去的必要了（

不过大多数人第一次看都会一头雾水，没关系，我们一步一步来。


### 理解算法的输入和输出

算法返回一个包含上下文和推导出的类型的元组。上下文是一个映射表，记录每个变量的类型，我们可以用Haskell的Data.Map来表示。

由于算法需要不断生成新的类型变量（如 A、B、C...），我们需要维护一个状态来记录当前使用到了哪个字母。为了简单起见，我们假设字母 A 到 Z 足够使用。

```haskell
data TypeCtx = TypeCtx
  { env :: Map Char CurryType,
    label :: Label
  }
```

定义主偶对（算法的返回结果）：
```haskell
type PrincipalPair = (TypeCtx, CurryType)
```

好，现在我们可以把算法的类型写出来了：

```haskell
emptyEnv :: TypeCtx
emptyEnv = TypeCtx Map.empty 'A'

pp :: Term -> PrincipalPair
-- 因为我们不能和定义里一样变出新类型名，我们得维护这个状态把它传来传去
pp = pp' emptyEnv
  where
    pp' :: TypeCtx -> Term -> PrincipalPair
    pp' = undefined -- 待实现
```

## 情况一：变量
实现式子是变量的情况：

![](/binary/pp_def_v.png)

这里公式说：看到任意变量x，推导出类型a（任意新类型名），并告诉上下文x被映射到a。

```haskell
pp' ctx (V c) =
  let (a, ctx') = next ctx -- 获取新类型名
   in (add c a ctx', a)    -- 返回({x: a}, a)
```

这里的 `next` 函数负责生成新类型名，`add` 函数负责向上下文中添加新的变量-类型映射。

```haskell
fresh :: Label -> Label
fresh = chr . (+ 1) . ord

next :: TypeCtx -> (CurryType, TypeCtx)
next (TypeCtx env l) = let l' = fresh l in (Phi l, TypeCtx env l')

add :: Char -> CurryType -> TypeCtx CurryType -> TypeCtx CurryType
add c ty (TypeCtx env l) = TypeCtx (Map.insert c ty env) l
```

## 情况二：抽象
![](/binary/pp_def_ab.png)

这个规则处理 Lambda 抽象 `\x.M`：
1. 首先推导 `M` 的类型 `P`
2. 检查上下文中是否已经知道 `x` 的类型：
   - 如果知道（比如 `x` 必须是 `Int -> Int`），则整个表达式的类型就是 `x的类型 -> P`
   - 如果不知道，就为 `x` 分配一个新类型 `a`，然后整个表达式的类型是 `a -> P`

```haskell
pp' ctx (Ab x m) = 
  let (ctx', p) = pp' ctx m  -- 先推导 M 的类型
  in case Map.lookup x (env ctx') of
    Just ty -> (del x ctx', ty --> p)  -- 如果已知 x 的类型
    Nothing -> 
      let (a, ctx'') = next ctx'  -- 否则创建新类型
      in (add x a ctx'', a --> p)
```

## 情况三：应用
实现式子是应用的情况：

![](/binary/pp_def_ap.png)

这是最复杂的情况，处理函数应用 `M N`：
1. 分别推导 `M` 和 `N` 的类型
2. 为了使应用成立，`M` 的类型必须是 `N的类型 -> 某个新类型`
3. 但之前我们给变量分配的类型是任意的，所以可能需要**统一（unify）** 这些类型

比如：推导`f x`的类型，递归给出f类型为A，x类型为B。这时候需要unify这个函数找出一个映射（把A替换成符合上下文的类型），使得被映射后M的类型可以被应用到N上，同时这个映射需要修改所有已知的上下文中的类型（UnifyContext）。

这部分内容比较复杂，我们将在下一篇文章中详细讲解。

```haskell
pp' ctx (Ap m n) = s2 . s1 $ (ctx1 `union` ctx3, a)
  where
    (ctx1, p1) = pp' ctx m
    (ctx2, p2) = pp' ctx1 n
    (a, ctx3) = next ctx2
    s1 = unify p1 (p2 --> a)
    s2 = unifyctx (s1 ctx1) (s1 ctx3)

unify :: CurryType -> CurryType -> (CurryType -> CurryType)
unifyctx :: TypeCtx -> TypeCtx -> (CurryType -> CurryType)
```

欲知后事如何，且听下回分解。
